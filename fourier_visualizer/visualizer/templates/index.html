<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Fourier Visualizer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;600&display=swap"
      rel="stylesheet"
    />
    <style>
      :root {
        --bg-color: #0f0f13;
        --panel-bg: rgba(30, 30, 40, 0.7);
        --accent: #7000ff;
        --accent-hover: #8a2be2;
        --text-main: #ffffff;
        --text-muted: #a0a0b0;
        --border: rgba(255, 255, 255, 0.1);
        --glass: blur(10px);
        --canvas-bg: radial-gradient(
          circle at center,
          #1a1a20 0%,
          #0f0f13 100%
        );
      }

      [data-theme="light"] {
        --bg-color: #f0f0f5;
        --panel-bg: rgba(255, 255, 255, 0.8);
        --accent: #7000ff;
        --accent-hover: #8a2be2;
        --text-main: #1a1a1a;
        --text-muted: #555566;
        --border: rgba(0, 0, 0, 0.1);
        --glass: blur(10px);
        --canvas-bg: radial-gradient(
          circle at center,
          #ffffff 0%,
          #e0e0e5 100%
        );
      }

      * {
        box-sizing: border-box;
      }

      body {
        margin: 0;
        background-color: var(--bg-color);
        color: var(--text-main);
        font-family: "Outfit", sans-serif;
        height: 100vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
        transition:
          background-color 0.3s,
          color 0.3s;
      }

      /* Layout */
      .app-container {
        display: flex;
        flex: 1;
        height: 100%;
        position: relative;
      }

      /* Sidebar Controls */
      .sidebar {
        width: 320px;
        background: var(--panel-bg);
        backdrop-filter: var(--glass);
        border-right: 1px solid var(--border);
        padding: 20px;
        display: flex;
        flex-direction: column;
        gap: 20px;
        z-index: 10;
        overflow-y: auto;
        transition: background-color 0.3s;
      }

      .logo {
        font-size: 1.5rem;
        font-weight: 600;
        color: var(--accent);
        margin-bottom: 10px;
        letter-spacing: -0.5px;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .theme-toggle {
        font-size: 1.2rem;
        cursor: pointer;
        opacity: 0.7;
        transition: opacity 0.2s;
        background: none;
        border: none;
        padding: 0;
        color: var(--text-main);
      }
      .theme-toggle:hover {
        opacity: 1;
      }

      .control-group {
        display: flex;
        flex-direction: column;
        gap: 8px;
      }

      label {
        font-size: 0.85rem;
        color: var(--text-muted);
        font-weight: 400;
      }

      input[type="range"] {
        width: 100%;
        accent-color: var(--accent);
        background: transparent;
        cursor: pointer;
      }

      input[type="number"] {
        background: rgba(0, 0, 0, 0.1);
        border: 1px solid var(--border);
        color: var(--text-main);
        padding: 8px;
        border-radius: 6px;
        font-family: inherit;
      }

      button {
        background: var(--accent);
        color: white;
        border: none;
        padding: 12px;
        border-radius: 8px;
        cursor: pointer;
        font-weight: 600;
        transition: all 0.2s ease;
        font-family: inherit;
      }

      button:hover {
        background: var(--accent-hover);
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(138, 43, 226, 0.3);
      }

      button.secondary {
        background: rgba(128, 128, 128, 0.1);
        color: var(--text-main);
      }

      button.secondary:hover {
        background: rgba(128, 128, 128, 0.2);
      }

      .tabs {
        display: flex;
        background: rgba(128, 128, 128, 0.1);
        padding: 4px;
        border-radius: 8px;
        margin-bottom: 10px;
      }

      .tab {
        flex: 1;
        text-align: center;
        padding: 8px;
        font-size: 0.9rem;
        cursor: pointer;
        border-radius: 6px;
        color: var(--text-muted);
        transition: 0.2s;
      }

      .tab.active {
        background: var(--panel-bg);
        color: var(--text-main);
        font-weight: 600;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      /* Main Canvas Area */
      .canvas-area {
        flex: 1;
        position: relative;
        background: var(--canvas-bg);
        display: flex;
        justify-content: center;
        align-items: center;
        overflow: hidden;
      }

      canvas {
        box-shadow: 0 0 50px rgba(0, 0, 0, 0.2);
        border-radius: 4px;
        cursor: crosshair;
        background: white;
        transition: box-shadow 0.3s;
      }

      #vizCanvas {
        background: transparent;
        pointer-events: none;
      }

      .hidden {
        display: none !important;
      }

      .status-pill {
        position: absolute;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        padding: 8px 16px;
        border-radius: 20px;
        font-size: 0.85rem;
        color: white;
        backdrop-filter: blur(4px);
        border: 1px solid var(--border);
        pointer-events: none;
        opacity: 0;
        transition: opacity 0.3s;
        z-index: 100;
      }
      .status-pill.visible {
        opacity: 1;
      }
    </style>
  </head>
  <body>
    <div class="app-container">
      <div class="sidebar">
        <div class="logo">
          Antigravity Fourier
          <button
            class="theme-toggle"
            onclick="toggleTheme()"
            title="Toggle Theme"
          >
            ðŸŒ“
          </button>
        </div>

        <!-- Mode Selection -->
        <div class="tabs">
          <div class="tab active" onclick="setMode('draw')">Draw</div>
          <div class="tab" onclick="setMode('upload')">Upload</div>
        </div>

        <!-- Draw Tools -->
        <div id="drawTools" class="control-group">
          <label>Drawing Actions</label>
          <button class="secondary" onclick="clearDrawing()">
            Clear Canvas
          </button>
          <button onclick="processDrawing()">âœ¨ Visualize Drawing</button>
        </div>

        <!-- Upload Tools -->
        <div id="uploadTools" class="control-group hidden">
          <label>Upload Image</label>
          <input
            type="file"
            id="imageInput"
            accept="image/*"
            style="font-size: 0.8rem; color: var(--text-muted)"
          />
          <button onclick="processUpload()">âœ¨ Visualize File</button>
        </div>

        <hr
          style="
            border: 0;
            border-top: 1px solid var(--border);
            width: 100%;
            margin: 10px 0;
          "
        />

        <!-- Visualization Controls -->
        <div class="control-group">
          <label>Number of Epicycles: <span id="armsVal">150</span></label>
          <input
            type="range"
            id="armsInput"
            min="1"
            max="500"
            value="150"
            oninput="updateArms(this.value)"
          />
        </div>

        <div class="control-group">
          <label
            >Speed (Period per stroke): <span id="speedVal">5s</span></label
          >
          <input
            type="range"
            id="speedInput"
            min="1"
            max="20"
            value="5"
            step="0.5"
            oninput="updateSpeed(this.value)"
          />
        </div>

        <div class="control-group">
          <label>Zoom</label>
          <input
            type="range"
            id="zoomInput"
            min="0.5"
            max="5"
            step="0.1"
            value="1"
            oninput="updateZoom(this.value)"
          />
        </div>

        <div class="control-group">
          <label>Camera</label>
          <button id="followBtn" class="secondary" onclick="toggleFollow()">
            Follow Pen: OFF
          </button>
        </div>

        <div class="control-group">
          <label>Path Color</label>
          <input
            type="color"
            id="pathColor"
            value="#7000ff"
            style="
              width: 100%;
              height: 40px;
              border: none;
              cursor: pointer;
              background: transparent;
            "
          />
        </div>
      </div>

      <div class="canvas-area" id="canvasContainer">
        <div id="statusPill" class="status-pill">Processing...</div>

        <!-- Drawing Canvas -->
        <canvas id="drawCanvas" width="800" height="600"></canvas>

        <!-- Visualization Canvas (Hidden initially) -->
        <canvas id="vizCanvas" width="800" height="600" class="hidden"></canvas>
      </div>
    </div>

    <script>
      // State
      let mode = "draw";
      let isDrawing = false;
      let drawCtx, vizCtx;

      // Drawing Data
      let currentStroke = [];
      let allStrokes = []; // List of strokes (list of points)

      // Visualization State
      let playlist = []; // List of coefficient lists
      let currentTrack = 0; // Index of current contour being drawn

      let isAnimating = false;
      let time = 0;
      let path = []; // Path of CURRENT stroke (World Coords)
      let completedPaths = []; // Paths of PREVIOUS strokes (World Coords)

      let lastFrameTime = 0;
      let period = 5; // Seconds per stroke
      let numArmsLimit = 150;

      // Camera State
      let camera = {
        x: 0,
        y: 0,
        zoom: 1,
        following: false,
      };

      // Theme
      let isDark = true;

      // DOM Elements
      const drawCanvas = document.getElementById("drawCanvas");
      const vizCanvas = document.getElementById("vizCanvas");
      const statusPill = document.getElementById("statusPill");

      // Init
      window.onload = () => {
        drawCtx = drawCanvas.getContext("2d");
        vizCtx = vizCanvas.getContext("2d");

        // Setup Drawing Canvas
        resetDrawCanvas();

        // Events
        drawCanvas.addEventListener("mousedown", startDrawing);
        drawCanvas.addEventListener("mousemove", draw);
        window.addEventListener("mouseup", stopDrawing);

        document
          .getElementById("imageInput")
          .addEventListener("change", processUpload);
      };

      function resetDrawCanvas() {
        drawCtx.fillStyle = "white";
        drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
        drawCtx.lineWidth = 3;
        drawCtx.lineCap = "round";
        drawCtx.strokeStyle = "black";
        allStrokes = [];
        currentStroke = [];
      }

      function toggleTheme() {
        isDark = !isDark;
        document.documentElement.setAttribute(
          "data-theme",
          isDark ? "dark" : "light",
        );
      }

      // --- Mode Switching ---
      function setMode(newMode) {
        try {
          const drawTools = document.getElementById("drawTools");
          const uploadTools = document.getElementById("uploadTools");
          const tabs = document.querySelectorAll(".tab");
          tabs.forEach((t) => t.classList.remove("active"));

          mode = newMode;

          if (newMode === "draw") {
            tabs[0].classList.add("active");
            drawTools.classList.remove("hidden");
            uploadTools.classList.add("hidden");

            stopAnimation();
            drawCanvas.classList.remove("hidden");
            vizCanvas.classList.add("hidden");
          } else {
            tabs[1].classList.add("active");
            drawTools.classList.add("hidden");
            uploadTools.classList.remove("hidden");
            // Upload mode automatically shows viz when ready
          }
        } catch (e) {
          console.error(e);
        }
      }

      // --- Drawing Logic ---
      function startDrawing(e) {
        if (mode !== "draw") return;
        isDrawing = true;
        currentStroke = [];

        const pt = getMousePos(e);
        currentStroke.push(pt);

        drawCtx.beginPath();
        drawCtx.moveTo(pt.x, pt.y);
      }

      function draw(e) {
        if (!isDrawing) return;
        const pt = getMousePos(e);
        currentStroke.push(pt); // Record point

        drawCtx.lineTo(pt.x, pt.y);
        drawCtx.stroke();
      }

      function stopDrawing() {
        if (!isDrawing) return;
        isDrawing = false;
        drawCtx.closePath();

        if (currentStroke.length > 2) {
          allStrokes.push(currentStroke);
        }
        currentStroke = [];
      }

      function getMousePos(e) {
        const rect = drawCanvas.getBoundingClientRect();
        return {
          x: e.clientX - rect.left,
          y: e.clientY - rect.top,
        };
      }

      function clearDrawing() {
        resetDrawCanvas();
        // Also clear visualization state
        playlist = [];
        completedPaths = [];
        path = [];
        currentTrack = 0;
        time = 0;
        isAnimating = false;

        // Reset Camera
        camera.x = 0;
        camera.y = 0;

        // Hide viz canvas if active
        setMode("draw");
      }

      // --- Processing Logic ---
      async function processDrawing() {
        if (allStrokes.length === 0) {
          alert("Draw something first!");
          return;
        }
        showStatus("Calculating Vector FFT...");

        await sendData({ strokes: allStrokes }, true);
      }

      async function processUpload() {
        const input = document.getElementById("imageInput");
        if (!input.files[0]) return;

        showStatus("Uploading & Processing...");

        const formData = new FormData();
        formData.append("drawing", input.files[0]);
        await sendData(formData, false);
      }

      async function sendData(bodyData, isJson) {
        try {
          const headers = { "X-CSRFToken": getCookie("csrftoken") };
          if (isJson) {
            headers["Content-Type"] = "application/json";
            bodyData = JSON.stringify(bodyData);
          }

          const response = await fetch("/process_upload/", {
            method: "POST",
            body: bodyData,
            headers: headers,
          });

          if (!response.ok) throw new Error("Server Error");

          const result = await response.json();
          if (result.status === "success") {
            playlist = result.data; // List of lists of coeffs
            startVisualization();
          } else {
            alert("Error: " + result.message);
            hideStatus();
          }
        } catch (e) {
          console.error(e);
          alert("Network error occurred.");
          hideStatus();
        }
      }

      // --- Visualization Logic ---
      function startVisualization() {
        hideStatus();
        drawCanvas.classList.add("hidden");
        vizCanvas.classList.remove("hidden");

        // Reset Animation State
        currentTrack = 0;
        path = [];
        completedPaths = [];
        time = 0;

        // Reset Camera
        camera.x = 0;
        camera.y = 0;

        if (!isAnimating) {
          isAnimating = true;
          lastFrameTime = performance.now();
          requestAnimationFrame(animate);
        }
      }

      function stopAnimation() {
        isAnimating = false;
      }

      function animate(now) {
        if (!isAnimating) return;

        // Delta Time
        const dt = (now - lastFrameTime) / 1000;
        lastFrameTime = now;

        // Update Time
        const angularSpeed = (2 * Math.PI) / period;
        time += angularSpeed * dt;

        // Check if stroke finished
        if (time > 2 * Math.PI) {
          // Stroke finished!
          // Save current path to persistent list
          if (path.length > 0) {
            completedPaths.push([...path]);
          }

          // Move to next stroke
          currentTrack++;
          time = 0;
          path = [];

          // Check if playlist finished
          if (currentTrack >= playlist.length) {
            // Loop entire animation?
            currentTrack = 0;
            completedPaths = [];
          }
        }

        renderFrame();
        requestAnimationFrame(animate);
      }

      // --- Coordinate Transform Helper ---
      function toScreen(worldX, worldY) {
        const cx = vizCanvas.width / 2;
        const cy = vizCanvas.height / 2;
        return {
          x: (worldX - camera.x) * camera.zoom + cx,
          y: (worldY - camera.y) * camera.zoom + cy,
        };
      }

      function renderFrame() {
        vizCtx.clearRect(0, 0, vizCanvas.width, vizCanvas.height);

        const pathColor = document.getElementById("pathColor").value;
        const trailColor = isDark
          ? "rgba(255, 255, 255, 0.1)"
          : "rgba(0, 0, 0, 0.1)";
        const armColor = isDark
          ? "rgba(255, 255, 255, 0.2)"
          : "rgba(0, 0, 0, 0.2)";

        // 1. Calculate Current Pen Position (World Coords)
        let penX = 0;
        let penY = 0;
        let epicycles = [];

        if (currentTrack < playlist.length) {
          const coeffs = playlist[currentTrack].slice(0, numArmsLimit);

          // Start at Origin (0,0) in World Space
          let x = 0;
          let y = 0;

          coeffs.forEach((c) => {
            const prevX = x;
            const prevY = y;
            const radius = c.radius;
            const angle = c.freq * time + c.phase;

            x += radius * Math.cos(angle);
            y += radius * Math.sin(angle);

            epicycles.push({ prevX, prevY, x, y, radius });
          });

          penX = x;
          penY = y;

          // Add to current Path
          path.push({ x: penX, y: penY });
          if (path.length > 5000) path.shift();
        }

        // 2. Update Camera
        if (camera.following) {
          // Smoothly interpolate camera to pen position
          const lerpFactor = 0.1;
          camera.x += (penX - camera.x) * lerpFactor;
          camera.y += (penY - camera.y) * lerpFactor;
        } else {
          // Center on origin (0,0)
          // We can just keep it at 0,0 or smooth back
          const lerpFactor = 0.05;
          camera.x += (0 - camera.x) * lerpFactor;
          camera.y += (0 - camera.y) * lerpFactor;
        }

        // 3. Draw Completed Paths (Dead ink)
        vizCtx.strokeStyle = pathColor;
        vizCtx.lineWidth = 2;
        vizCtx.globalAlpha = 0.6; // Slight fade for finished ink

        completedPaths.forEach((p) => {
          if (p.length < 2) return;
          vizCtx.beginPath();

          const start = toScreen(p[0].x, p[0].y);
          vizCtx.moveTo(start.x, start.y);

          for (let i = 1; i < p.length; i++) {
            // Optimization: skip large jumps in World Space (retrace jumps)
            const dist = Math.hypot(p[i].x - p[i - 1].x, p[i].y - p[i - 1].y);
            const screenPt = toScreen(p[i].x, p[i].y);

            // Threshold in World Units! (approx 100 pixels in default zoom)
            if (dist < 100) {
              vizCtx.lineTo(screenPt.x, screenPt.y);
            } else {
              vizCtx.moveTo(screenPt.x, screenPt.y);
            }
          }
          vizCtx.stroke();
        });
        vizCtx.globalAlpha = 1.0;

        // 4. Draw Current Path
        if (path.length > 0) {
          vizCtx.strokeStyle = pathColor;
          vizCtx.lineWidth = 2;
          vizCtx.beginPath();

          const start = toScreen(path[0].x, path[0].y);
          vizCtx.moveTo(start.x, start.y);

          for (let i = 1; i < path.length; i++) {
            const dist = Math.hypot(
              path[i].x - path[i - 1].x,
              path[i].y - path[i - 1].y,
            );
            const screenPt = toScreen(path[i].x, path[i].y);

            if (dist < 100) {
              vizCtx.lineTo(screenPt.x, screenPt.y);
            } else {
              vizCtx.moveTo(screenPt.x, screenPt.y);
            }
          }
          vizCtx.stroke();
        }

        // 5. Draw Epicycles & Pen
        if (currentTrack < playlist.length) {
          epicycles.forEach((c) => {
            // Optimization: Don't draw tiny circles if zoomed out
            // Screen radius
            const screenRadius = c.radius * camera.zoom;
            if (screenRadius < 0.5) return;

            const center = toScreen(c.prevX, c.prevY);
            const tip = toScreen(c.x, c.y);

            vizCtx.beginPath();
            vizCtx.strokeStyle = trailColor;
            vizCtx.arc(center.x, center.y, screenRadius, 0, 2 * Math.PI);
            vizCtx.stroke();

            // Draw Arm Line always? Or just large ones?
            if (screenRadius > 2) {
              vizCtx.beginPath();
              vizCtx.strokeStyle = armColor;
              vizCtx.moveTo(center.x, center.y);
              vizCtx.lineTo(tip.x, tip.y);
              vizCtx.stroke();
            }
          });

          // Pen Tip
          const penScreen = toScreen(penX, penY);
          vizCtx.fillStyle = pathColor;
          vizCtx.beginPath();
          vizCtx.arc(penScreen.x, penScreen.y, 4, 0, 2 * Math.PI);
          vizCtx.fill();
        }
      }

      // --- Controls ---
      function updateArms(val) {
        document.getElementById("armsVal").innerText = val;
        numArmsLimit = parseInt(val);
      }

      function updateSpeed(val) {
        document.getElementById("speedVal").innerText = val + "s";
        period = parseFloat(val);
      }

      function updateZoom(val) {
        // Logarithmic zoom feel?
        // normalized 0.5 to 5 is fine for now
        camera.zoom = parseFloat(val);
        // Do NOT clear path! We want to see it just zoomed.
      }

      function toggleFollow() {
        camera.following = !camera.following;
        const btn = document.getElementById("followBtn");
        btn.innerText = "Follow Pen: " + (camera.following ? "ON" : "OFF");
        btn.style.background = camera.following
          ? "var(--accent)"
          : "rgba(128, 128, 128, 0.1)";
        btn.style.color = camera.following ? "white" : "var(--text-main)";
      }

      function showStatus(msg) {
        if (statusPill) {
          statusPill.innerText = msg;
          statusPill.classList.add("visible");
        }
      }
      function hideStatus() {
        if (statusPill) statusPill.classList.remove("visible");
      }

      // Helper for CSRF token
      function getCookie(name) {
        let cookieValue = null;
        if (document.cookie && document.cookie !== "") {
          const cookies = document.cookie.split(";");
          for (let i = 0; i < cookies.length; i++) {
            const cookie = cookies[i].trim();
            if (cookie.substring(0, name.length + 1) === name + "=") {
              cookieValue = decodeURIComponent(
                cookie.substring(name.length + 1),
              );
              break;
            }
          }
        }
        return cookieValue;
      }
    </script>
  </body>
</html>
